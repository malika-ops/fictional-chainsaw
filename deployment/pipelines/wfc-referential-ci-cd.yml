trigger:
- main

resources:
  - repo: self

parameters:
  - name: Build_Release
    type: boolean
    default: true
  - name: Run_Fortify_Scan
    type: boolean
    default: true
    
name: 9.9$(Rev:.r)

variables:
  - name: currentBranchName 
    value: '$(Build.SourceBranchName)'
  - name: buildConfiguration 
    value: 'Release'
  - name: imageRepository 
    value: 'phoenix/wfc-referential-api'
  - name: tag 
    value: '$(Build.BuildId)'
  - name: dockerRegistryServiceConnection
    value: 'Harbor-Registry'
  # Fortify Variables
  - name: fortifyProjectName
    value: 'wfc-referential-api'
  - name: fortifyProjectVersion
    value: '$(Build.SourceBranchName)'
  - name: fortifyScanId
    value: 'wfc-referential-api-$(Build.BuildId)'
  - name: fortifyProjectID
    value: '10005'


stages:
- stage: Build_CI
  condition: eq(${{parameters.Build_Release}}, 'true')
  displayName: Build CI
  jobs:
  - job: Build_CI
    displayName: Build and push image docker
    pool:
      name: Agents_Win_Linux
      demands: Agent.OS -equals Linux
    workspace:
      clean: all
    steps:
    - task: UseDotNet@2
      displayName: "Use .NET Core sdk 8.0.x"
      inputs:
        version: 8.0.x

    - task: NuGetToolInstaller@1
      displayName: 'Use NuGet'
      inputs:
        versionSpec: '6.x'

    - task: NuGetAuthenticate@1
      displayName: 'NuGet Authenticate'
      inputs:
        forceReinstallCredentialProvider: true
      env:
        DOTNET_SYSTEM_NET_HTTP_USESOCKETSHTTPHANDLER: '0'
        SSL_CERT_FILE: '/etc/ssl/certs/wafacash-MASSA-CA.crt'
        SSL_CERT_DIR: '/etc/ssl/certs'
        NODE_EXTRA_CA_CERTS: '/etc/ssl/certs/ca-certificates.crt'
        REQUESTS_CA_BUNDLE: '/etc/ssl/certs/ca-certificates.crt'
        CURL_CA_BUNDLE: '/etc/ssl/certs/ca-certificates.crt'
        NODE_TLS_REJECT_UNAUTHORIZED: '0'

    - task: DotNetCoreCLI@2
      displayName: 'Restore solution'
      inputs:
        command: 'restore'
        projects: 'src/**/**/*.csproj'
        feedsToUse: 'config'
        nugetConfigPath: 'nuget.config'
        workingDirectory: '$(Build.SourcesDirectory)'

    - task: DotNetCoreCLI@2
      displayName: 'Build solution'
      inputs:
        command: 'build'
        projects: 'src/**/**/*.csproj'
        arguments: '--configuration $(buildConfiguration) --no-restore'
        
    - task: DotNetCoreCLI@2
      displayName: 'Add coverlet.collector package'
      inputs:
        command: 'custom'
        custom: 'add'
        arguments: 'package coverlet.collector'
        projects: '**/*[Tt]ests.csproj'

    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests'
      timeoutInMinutes: 10
      inputs:
        command: 'test'
        projects: '**/*[Tt]ests.csproj'
        arguments: '--configuration $(buildConfiguration) --logger "trx" --collect:"XPlat Code Coverage" --results-directory $(Agent.TempDirectory)/TestResults'
        publishTestResults: false  # Changed to false - we'll publish manually
        failTaskOnFailedTests: true
        workingDirectory: '$(Build.SourcesDirectory)'
    
    # Publish test results
    - task: PublishTestResults@2
      displayName: 'Publish Test Results'
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '**/*.trx'  # Changed to search for all .trx files
        searchFolder: '$(Agent.TempDirectory)/TestResults'  # Specific folder
        mergeTestResults: true
        failTaskOnFailedTests: true
        testRunTitle: 'Unit Tests - $(Build.BuildNumber)'
      condition: succeededOrFailed()

    - task: DotNetCoreCLI@2
      displayName: "publish solution"
      inputs:
        command: publish
        publishWebProjects: false
        projects: 'src/**/**/*.csproj'
        zipAfterPublish: false
        arguments: "-o $(Build.SourcesDirectory)/src/Output"

    - script: |
        echo "Contents of the publish directory:"
        ls -R $(Build.SourcesDirectory)/src/Output
      displayName: 'Display publish directory contents'

    - task: Docker@2
      displayName: Docker Build
      inputs:
        command: Build
        dockerfile: $(Build.SourcesDirectory)/deployment/dockerfile/wfc-referential-api.dockerfile
        buildContext: $(Build.SourcesDirectory)
        containerRegistry: $(dockerRegistryServiceConnection)
        repository: $(imageRepository)
        tags: |
          latest
          $(tag)
        arguments: "--build-arg NUGET_PAT=$(System.AccessToken)"

    - task: Docker@2
      displayName: Docker Push to Harbor
      inputs:
        command: Push
        dockerfile: $(Build.SourcesDirectory)/deployment/dockerfile/wfc-referential-api.dockerfile
        buildContext: $(Build.SourcesDirectory)
        containerRegistry: $(dockerRegistryServiceConnection)
        repository: $(imageRepository)
        tags: |
          latest
          $(tag)

# Stage 2: Fortify Security Scan (runs in parallel after build artifacts are published)
- stage: Fortify_Security_Scan
  condition: and(succeeded(), eq(${{parameters.Run_Fortify_Scan}}, 'true'))
  displayName: Fortify Security Scan
  dependsOn: []  # Runs independently to maximize parallelism
  jobs:
  - job: Fortify_Scan
    displayName: Fortify Static Code Analysis
    pool:
      name: Agents_Win_Linux
      demands: 
        - Agent.OS -equals Linux
        - fortify  
    timeoutInMinutes: 120  
    workspace:
      clean: all
    variables:
    - group: SecurityToolsLibrary
    steps:
    - task: Bash@3
      displayName: 'Verify Fortify Installation'
      inputs:
        targetType: 'inline'
        script: |
          /home/wfc/fortify/fortify_sca_24.4.0/bin/sourceanalyzer -version

    # Clean previous scan artifacts
    - script: |
        /home/wfc/fortify/fortify_sca_24.4.0/bin/sourceanalyzer -b $(fortifyScanId) -clean
      displayName: 'Clean Fortify Build Session'
      continueOnError: true

    - script: |
        echo "Contents of SourcesDirectory:"
        ls -R $(Build.SourcesDirectory)/src
      displayName: 'Display Build.SourcesDirectory contents'

    # Translate source code
    - script: |
        echo "Starting Fortify translation..."
        /home/wfc/fortify/fortify_sca_24.4.0/bin/sourceanalyzer -b $(fortifyScanId) \
          -dotnet-version 8.0 \
          -exclude "$(Build.SourcesDirectory)/src/**/Migrations/**" \
          -libdirs "$(Build.SourcesDirectory)/src/**/bin/$(buildConfiguration)" \
          "$(Build.SourcesDirectory)/src/**/*.cs" \
          "$(Build.SourcesDirectory)/src/**/*.csproj"
      displayName: 'Fortify - Translate Source Code'
      timeoutInMinutes: 30

    # Scan source code
    - script: |
        echo "Starting Fortify scan..."
        /home/wfc/fortify/fortify_sca_24.4.0/bin/sourceanalyzer -b $(fortifyScanId) \
          -scan \
          -f "$(Build.SourcesDirectory)/$(fortifyScanId).fpr" \
          -format fpr \
          -verbose \
          -Xmx4G \
          -Xms2G \
          -Xss24M
      displayName: 'Fortify - Scan Source Code'
      timeoutInMinutes: 60

    - script: |
        echo "Contents of SourcesDirectory:"
        ls -R $(Build.SourcesDirectory)
      displayName: 'Display Fortify directory contents'

    - task: Bash@3
      displayName: 'Debug - List Available Projects and Versions'
      inputs:
        targetType: 'inline'
        script: |
          # Install jq if needed
          which jq || (sudo apt-get update && sudo apt-get install -y jq)

          # Using the token from the library group
          SSC_URL="$(Fortify_SSC_URL)"
          AUTH_TOKEN="$(FortifyAuthToken)"

          echo "=== Testing API Connection ==="
          echo "Testing connection to: $SSC_URL with this token : $AUTH_TOKEN "

          # Test basic connectivity
          SERVER_VERSION=$(curl -k -s \
            -H "Authorization: FortifyToken $AUTH_TOKEN" \
            "$SSC_URL/api/v1/serverVersion" 2>&1)

          echo "Server response: $SERVER_VERSION"

          echo ""
          echo "=== Pipeline Variables ==="
          echo "fortifyProjectName: '$(fortifyProjectName)'"
          echo "fortifyProjectVersion: '$(fortifyProjectVersion)'"

          echo ""
          echo "=== Available Projects ==="

          PROJECTS_RESPONSE=$(curl -k -s \
            -H "Authorization: FortifyToken $AUTH_TOKEN" \
            "$SSC_URL/api/v1/projects")

          echo "Projects API Response:"
          echo "$PROJECTS_RESPONSE"

          # Check if response is valid JSON
          if echo "$PROJECTS_RESPONSE" | jq empty 2>/dev/null; then
            echo ""
            echo "=== Formatted Project List ==="
            echo "$PROJECTS_RESPONSE" | jq -r '.data[] | "Project ID: \(.id) | Name: \(.name)"'

            echo ""
            echo "=== Available Project Versions ==="
            PROJECT_VERSIONS_RESPONSE=$(curl -k -s \
              -H "Authorization: FortifyToken $AUTH_TOKEN" \
              "$SSC_URL/api/v1/projectVersions")

            echo "$PROJECT_VERSIONS_RESPONSE" | jq -r '.data[] | "Project: \(.project.name) | Version: \(.name) | ID: \(.id)"'

            echo ""
            echo "=== Looking for Exact Match ==="
            EXACT_MATCH=$(echo "$PROJECT_VERSIONS_RESPONSE" | jq -r --arg proj "$(fortifyProjectName)" --arg ver "$(fortifyProjectVersion)" '.data[] | select(.project.name == $proj and .name == $ver) | "Found: Project=\(.project.name), Version=\(.name), ID=\(.id)"')

            if [ -n "$EXACT_MATCH" ]; then
              echo "‚úÖ $EXACT_MATCH"
            else
              echo "‚ùå No exact match found for project='$(fortifyProjectName)' version='$(fortifyProjectVersion)'"

              echo ""
              echo "=== Similar Projects (case-insensitive search) ==="
              echo "$PROJECT_VERSIONS_RESPONSE" | jq -r --arg proj "$(fortifyProjectName)" '.data[] | select(.project.name | ascii_downcase | contains($proj | ascii_downcase)) | "Similar: \(.project.name) | Version: \(.name)"'
            fi

          else
            echo "‚ùå Invalid JSON response or API error"
            echo "Raw response: $PROJECTS_RESPONSE"
          fi

    - task: Bash@3
      displayName: 'Upload FPR to Existing Version'
      inputs:
        targetType: 'inline'
        script: |
          which jq || (sudo apt-get update && sudo apt-get install -y jq)

          # Using the token from the library group
          SSC_URL="$(Fortify_SSC_URL)"
          AUTH_TOKEN="$(FortifyAuthToken)"

          FPR_FILE="$(Build.SourcesDirectory)/$(fortifyScanId).fpr"

          # Use the existing project version ID: $(fortifyProjectID)
          PROJECT_VERSION_ID="$(fortifyProjectID)" 

          # echo "‚úÖ Using existing project version:"
          # echo "   Project: wfc-referential-api"  
          # echo "   Version: 1.0"
          # echo "   ID: $(fortifyProjectID)"

          # Verify FPR file exists
          if [ ! -f "$FPR_FILE" ]; then
            echo "‚ùå FPR file not found: $FPR_FILE"
            exit 1
          fi

          echo "üìÅ FPR file: $FPR_FILE ($(du -h "$FPR_FILE" | cut -f1))"

          # Upload FPR
          echo "üöÄ Uploading FPR file..."
          UPLOAD_RESULT=$(curl -k -s -w "HTTPSTATUS:%{http_code}" \
            -H "Authorization: FortifyToken $AUTH_TOKEN" \
            -F "file=@$FPR_FILE" \
            "$SSC_URL/api/v1/projectVersions/$PROJECT_VERSION_ID/artifacts")

          # Extract HTTP status and body
          HTTP_STATUS=$(echo $UPLOAD_RESULT | tr -d '\n' | sed -e 's/.*HTTPSTATUS://')
          HTTP_BODY=$(echo $UPLOAD_RESULT | sed -e 's/HTTPSTATUS:.*//g')

          echo "HTTP Status: $HTTP_STATUS"
          echo "Response: $HTTP_BODY"

          if [ "$HTTP_STATUS" -eq 200 ] || [ "$HTTP_STATUS" -eq 201 ]; then
            echo "‚úÖ FPR uploaded successfully to wfc-referential-api v1.0!"

            # Try to extract artifact ID
            if echo "$HTTP_BODY" | jq empty 2>/dev/null; then
              ARTIFACT_ID=$(echo "$HTTP_BODY" | jq -r '.data.id // "unknown"')
              echo "üÜî Artifact ID: $ARTIFACT_ID"
            fi
          else
            echo "‚ùå Upload failed with status $HTTP_STATUS"
            echo "Response body: $HTTP_BODY"
            exit 1
          fi

    - task: Bash@3
      displayName: 'Convert FPR to HTML Report'
      inputs:
        targetType: 'inline'
        script: |
          # Define paths
          FPR_FILE="$(Build.SourcesDirectory)/$(fortifyScanId).fpr"
          HTML_OUTPUT="$(Build.ArtifactStagingDirectory)/fortify-security-report.html"
          FORTIFY_BIN="/home/wfc/fortify/fortify_sca_24.4.0/bin"

          # Verify FPR file exists
          if [ ! -f "$FPR_FILE" ]; then
            echo "‚ùå FPR file not found: $FPR_FILE"
            exit 1
          fi

          echo "üìÑ Converting FPR to HTML..."
          echo "   Input: $FPR_FILE"
          echo "   Output: $HTML_OUTPUT"

          # Create output directory if it doesn't exist
          mkdir -p "$(Build.ArtifactStagingDirectory)"

          # Generate HTML report
          "$FORTIFY_BIN/FPRUtility" \
            -information \
            -listIssues \
            -categoryIssueCounts \
            -project "$FPR_FILE" \
            -f "$HTML_OUTPUT"

          # Check if HTML was created successfully
          if [ -f "$HTML_OUTPUT" ]; then
            echo "‚úÖ HTML report generated successfully!"
            echo "üìä Report size: $(du -h "$HTML_OUTPUT" | cut -f1)"
          else
            echo "‚ùå Failed to generate HTML report"
            exit 1
          fi

    - task: PublishBuildArtifacts@1
      displayName: 'Publish HTML Report as Artifact'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/fortify-security-report.html'
        ArtifactName: 'FortifySecurityReport'
        publishLocation: 'Container'
      condition: always()

    - task: Bash@3
      displayName: 'Display Fortify HTML Report Contents'
      inputs:
        targetType: 'inline'
        script: |
          HTML_FILE="$(Build.ArtifactStagingDirectory)/fortify-security-report.html"
          
          echo "üìÑ Contents of fortify-security-report.html:"
          echo "============================================="
          
          if [ -f "$HTML_FILE" ]; then
            cat "$HTML_FILE"
          else
            echo "‚ùå HTML file not found: $HTML_FILE"
            echo "üìÅ Files in artifact directory:"
            ls -la "$(Build.ArtifactStagingDirectory)/"
          fi

- stage: DeployDev
  displayName: Deploy to Development
  dependsOn: Build_CI
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: DeployDev
    displayName: Deploy to Dev Environment
    pool:
      name: Agents_Win_Linux
      demands: Agent.OS -equals Linux
    workspace:
      clean: all
    environment: 'DEV'
    variables:
    - group: DEV
    strategy:
      runOnce:
        deploy:
          steps:
          # Work directly with source files - no artifacts needed
          - checkout: self
            clean: true
            displayName: 'Checkout source code'

          - script: |
              echo "=== Checking deployment files ==="
              ls -la $(Build.SourcesDirectory)/deployment/k8-manifests/ || echo "k8-manifests not found"
              ls -la $(Build.SourcesDirectory)/deployment/phoenix/ || echo "phoenix not found"
            displayName: 'Verify deployment files exist'

          - task: qetza.replacetokens.replacetokens-task.replacetokens@6
            displayName: 'Replace tokens in manifests'
            inputs:
              rootDirectory: '$(Build.SourcesDirectory)/deployment/k8-manifests'
              targetFiles: '**/*.yml'
              encoding: 'auto'
              tokenPattern: 'default'
              writeBOM: true
              actionOnMissing: 'warn'
              keepToken: false
              actionOnNoFiles: 'continue'
              enableTransforms: false
              enableRecursion: false
              useLegacyPattern: false
              enableTelemetry: true

          - task: Bash@3
            displayName: 'Deploy to Kubernetes cluster'
            inputs:
              targetType: 'inline'
              script: |
                MANIFEST_DIR="$(Build.SourcesDirectory)/deployment/k8-manifests/"
                
                echo "=== Verifying manifest files exist ==="
                if [ ! -d "$MANIFEST_DIR" ]; then
                    echo "ERROR: Manifest directory not found at $MANIFEST_DIR"
                    exit 1
                fi
                
                echo "Files in manifest directory:"
                ls -la "$MANIFEST_DIR"
                
                echo "=== Applying Kubernetes manifests ==="
                
                # Apply manifests one by one with error checking
                apply_manifest() {
                    local file="$1"
                    if [ -f "$file" ]; then
                        echo "Applying $file..."
                        kubectl apply -f "$file"
                        if [ $? -eq 0 ]; then
                            echo "‚úì Successfully applied $file"
                        else
                            echo "‚úó Failed to apply $file"
                            return 1
                        fi
                    else
                        echo "‚ö† File $file not found, skipping..."
                    fi
                }
                
                # Apply in correct order
                apply_manifest "$MANIFEST_DIR/local-storageclass.yml"
                apply_manifest "$MANIFEST_DIR/local-pv.yml"
                apply_manifest "$MANIFEST_DIR/namespace.yml"
                apply_manifest "$MANIFEST_DIR/local-pvc.yml"
                apply_manifest "$MANIFEST_DIR/configmap.yml"
                apply_manifest "$MANIFEST_DIR/secret.yml"
                apply_manifest "$MANIFEST_DIR/service.yml"
                apply_manifest "$MANIFEST_DIR/deployment.yml"

                # apply_manifest "$MANIFEST_DIR/ingress.yml"  # Commented out as in original
                
                echo "=== Cleaning up Docker resources ==="
                echo "Removing unused Docker images..."
                docker rmi -f $(docker images -q) 2>/dev/null || echo "No images to remove or command failed"
                
                echo "Pruning Docker system..."
                docker system prune -a --volumes --force || echo "Docker system prune failed"
                
                echo "=== Deployment completed ==="

          - script: echo $(ConnectionStrings__wfc.referential.dbc)
            displayName: 'Display connection string value'

          - task: UseDotNet@2
            displayName: "Use .NET Core sdk 8.0.x"
            inputs:
              version: 8.0.x

          - task: NuGetAuthenticate@1
            displayName: 'NuGet Authenticate'
            inputs:
              forceReinstallCredentialProvider: true
            env:
              DOTNET_SYSTEM_NET_HTTP_USESOCKETSHTTPHANDLER: '0'
              SSL_CERT_FILE: '/etc/ssl/certs/wafacash-MASSA-CA.crt'
              SSL_CERT_DIR: '/etc/ssl/certs'
              NODE_EXTRA_CA_CERTS: '/etc/ssl/certs/ca-certificates.crt'
              REQUESTS_CA_BUNDLE: '/etc/ssl/certs/ca-certificates.crt'
              CURL_CA_BUNDLE: '/etc/ssl/certs/ca-certificates.crt'
              NODE_TLS_REJECT_UNAUTHORIZED: '0'

          - task: DotNetCoreCLI@2
            displayName: 'Install EF Tools'
            inputs:
              command: 'custom'
              custom: 'tool'
              arguments: 'install --global dotnet-ef'
              
          - task: DotNetCoreCLI@2
            displayName: 'Apply EF Migrations'
            env:
              ConnectionStrings__Database: $(ConnectionStrings__wfc.referential.dbc)
            inputs:
              command: 'custom'
              custom: 'ef' 
              arguments: 'database update --project $(Build.SourcesDirectory)/src/04.Infrastructure/wfc.referential.Infrastructure/wfc.referential.Infrastructure.csproj --startup-project $(Build.SourcesDirectory)/src/01.InterfaceAdapter/wfc.referential.API/wfc.referential.API.csproj'  

          - task: Bash@3
            displayName: 'Phoenix done!'
            inputs:
              targetType: 'inline'
              script: |
                PHOENIX_FILE="$(Build.SourcesDirectory)/deployment/phoenix/readme-dev"
                echo "=== Phoenix Phase ==="
                if [ -f "$PHOENIX_FILE" ]; then
                    echo "Phoenix readme-dev contents:"
                    cat "$PHOENIX_FILE"
                else
                    echo "Phoenix readme-dev file not found at $PHOENIX_FILE"
                    echo "Available files in phoenix directory:"
                    ls -la "$(Build.SourcesDirectory)/deployment/phoenix/" 2>/dev/null || echo "Phoenix directory not found"
                fi

- stage: DeployPprod
  displayName: Deploy to PPROD
  dependsOn: 
  - Build_CI
  - DeployDev
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  # Pre-deployment approval
  - job: PreDeploymentApproval
    displayName: 'Pre-Deployment Approval Gate'
    pool: server
    timeoutInMinutes: 4320 # 3 days timeout
    variables:
    - group: PPROD
    
    steps:
    - task: ManualValidation@0
      displayName: 'Manual Approval Required'
      inputs:
        notifyUsers: "$(notifyUsers)"
        instructions: |
          Please review the following before approving deployment to PRE-PROD:
          
          ‚úÖ Build Quality Gates Passed
          ‚úÖ Unit Tests Passed  
          ‚úÖ Security Scan Completed
          ‚úÖ Performance Tests Validated
          ‚úÖ Business Stakeholder Sign-off
          
          Deployment Details:
          - Build Number: $(Build.BuildNumber)
          - Source Branch: $(Build.SourceBranch)
          - Triggered By: $(Build.RequestedFor)
          
          Check the boxes above and click "Resume" to proceed with dev deployment.
        onTimeout: 'reject'
        
  - deployment: DeployPprod
    displayName: Deploy to PRE-PRODUCTION Environment
    dependsOn: PreDeploymentApproval
    pool:
      name: Agents_Win_Linux
      demands: Agent.OS -equals Linux
    workspace:
      clean: all
    environment: 'PPROD'
    variables:
    - group: PPROD
    strategy:
      runOnce:
        deploy:
          steps:
          # Work directly with source files - no artifacts needed
          - checkout: self
            clean: true
            displayName: 'Checkout source code'

          - script: |
              echo "=== Checking deployment files ==="
              ls -la $(Build.SourcesDirectory)/deployment/k8-manifests/ || echo "k8-manifests not found"
              ls -la $(Build.SourcesDirectory)/deployment/phoenix/ || echo "phoenix not found"
            displayName: 'Verify deployment files exist'

          - task: qetza.replacetokens.replacetokens-task.replacetokens@6
            displayName: 'Replace tokens in manifests'
            inputs:
              rootDirectory: '$(Build.SourcesDirectory)/deployment/k8-manifests'
              targetFiles: '**/*.yml'
              encoding: 'auto'
              tokenPattern: 'default'
              writeBOM: true
              actionOnMissing: 'warn'
              keepToken: false
              actionOnNoFiles: 'continue'
              enableTransforms: false
              enableRecursion: false
              useLegacyPattern: false
              enableTelemetry: true

          - task: Bash@3
            displayName: 'Deploy to Kubernetes cluster'
            inputs:
              targetType: 'inline'
              script: |
                MANIFEST_DIR="$(Build.SourcesDirectory)/deployment/k8-manifests/"
                
                echo "=== Verifying manifest files exist ==="
                if [ ! -d "$MANIFEST_DIR" ]; then
                    echo "ERROR: Manifest directory not found at $MANIFEST_DIR"
                    exit 1
                fi
                
                echo "Files in manifest directory:"
                ls -la "$MANIFEST_DIR"
                
                echo "=== Applying Kubernetes manifests ==="
                
                # Apply manifests one by one with error checking
                apply_manifest() {
                    local file="$1"
                    if [ -f "$file" ]; then
                        echo "Applying $file..."
                        kubectl apply -f "$file"
                        if [ $? -eq 0 ]; then
                            echo "‚úì Successfully applied $file"
                        else
                            echo "‚úó Failed to apply $file"
                            return 1
                        fi
                    else
                        echo "‚ö† File $file not found, skipping..."
                    fi
                }
                
                # Apply in correct order
                apply_manifest "$MANIFEST_DIR/local-storageclass.yml"
                apply_manifest "$MANIFEST_DIR/local-pv.yml"
                apply_manifest "$MANIFEST_DIR/namespace.yml"
                apply_manifest "$MANIFEST_DIR/local-pvc.yml"
                apply_manifest "$MANIFEST_DIR/configmap.yml"
                apply_manifest "$MANIFEST_DIR/secret.yml"
                apply_manifest "$MANIFEST_DIR/service.yml"
                apply_manifest "$MANIFEST_DIR/deployment.yml"
                # apply_manifest "$MANIFEST_DIR/ingress.yml"  # Commented out as in original
                
                echo "=== Cleaning up Docker resources ==="
                echo "Removing unused Docker images..."
                docker rmi -f $(docker images -q) 2>/dev/null || echo "No images to remove or command failed"
                
                echo "Pruning Docker system..."
                docker system prune -a --volumes --force || echo "Docker system prune failed"
                
                echo "=== Deployment completed ==="

          - task: Bash@3
            displayName: 'Phoenix done!'
            inputs:
              targetType: 'inline'
              script: |
                PHOENIX_FILE="$(Build.SourcesDirectory)/deployment/phoenix/readme-pprd"
                echo "=== Phoenix Phase ==="
                if [ -f "$PHOENIX_FILE" ]; then
                    echo "Phoenix readme-dev contents:"
                    cat "$PHOENIX_FILE"
                else
                    echo "Phoenix readme-dev file not found at $PHOENIX_FILE"
                    echo "Available files in phoenix directory:"
                    ls -la "$(Build.SourcesDirectory)/deployment/phoenix/" 2>/dev/null || echo "Phoenix directory not found"

- stage: DeployProd
  displayName: Deploy to Production
  dependsOn: 
  - Build_CI
  - DeployPprod
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  # Pre-deployment approval
  - job: PreDeploymentApproval
    displayName: 'Pre-Deployment Approval Gate'
    pool: server
    timeoutInMinutes: 4320 # 3 days timeout
    variables:
    - group: PROD
    
    steps:
    - task: ManualValidation@0
      displayName: 'Manual Approval Required'
      inputs:
        notifyUsers: "$(notifyUsers)"
        instructions: |
          Please review the following before approving deployment to PROD:
          
          ‚úÖ Build Quality Gates Passed
          ‚úÖ Unit Tests Passed  
          ‚úÖ Security Scan Completed
          ‚úÖ Performance Tests Validated
          ‚úÖ Business Stakeholder Sign-off
          
          Deployment Details:
          - Build Number: $(Build.BuildNumber)
          - Source Branch: $(Build.SourceBranch)
          - Triggered By: $(Build.RequestedFor)
          
          Check the boxes above and click "Resume" to proceed with dev deployment.
        onTimeout: 'reject'
        
  - deployment: DeployProd
    displayName: Deploy to Prod Environment
    dependsOn: PreDeploymentApproval
    pool:
      name: Agents_Win_Linux
      demands: Agent.OS -equals Linux
    workspace:
      clean: all
    environment: 'PROD'
    variables:
    - group: PROD
    strategy:
      runOnce:
        deploy:
          steps:
          # Work directly with source files - no artifacts needed
          - checkout: self
            clean: true
            displayName: 'Checkout source code'

          - script: |
              echo "=== Checking deployment files ==="
              ls -la $(Build.SourcesDirectory)/deployment/k8-manifests/ || echo "k8-manifests not found"
              ls -la $(Build.SourcesDirectory)/deployment/phoenix/ || echo "phoenix not found"
            displayName: 'Verify deployment files exist'

          - task: qetza.replacetokens.replacetokens-task.replacetokens@6
            displayName: 'Replace tokens in manifests'
            inputs:
              rootDirectory: '$(Build.SourcesDirectory)/deployment/k8-manifests'
              targetFiles: '**/*.yml'
              encoding: 'auto'
              tokenPattern: 'default'
              writeBOM: true
              actionOnMissing: 'warn'
              keepToken: false
              actionOnNoFiles: 'continue'
              enableTransforms: false
              enableRecursion: false
              useLegacyPattern: false
              enableTelemetry: true

          - task: Bash@3
            displayName: 'Deploy to Kubernetes cluster'
            inputs:
              targetType: 'inline'
              script: |
                MANIFEST_DIR="$(Build.SourcesDirectory)/deployment/k8-manifests/"
                
                echo "=== Verifying manifest files exist ==="
                if [ ! -d "$MANIFEST_DIR" ]; then
                    echo "ERROR: Manifest directory not found at $MANIFEST_DIR"
                    exit 1
                fi
                
                echo "Files in manifest directory:"
                ls -la "$MANIFEST_DIR"
                
                echo "=== Applying Kubernetes manifests ==="
                
                # Apply manifests one by one with error checking
                apply_manifest() {
                    local file="$1"
                    if [ -f "$file" ]; then
                        echo "Applying $file..."
                        kubectl apply -f "$file"
                        if [ $? -eq 0 ]; then
                            echo "‚úì Successfully applied $file"
                        else
                            echo "‚úó Failed to apply $file"
                            return 1
                        fi
                    else
                        echo "‚ö† File $file not found, skipping..."
                    fi
                }
                
                # Apply in correct order
                apply_manifest "$MANIFEST_DIR/local-storageclass.yml"
                apply_manifest "$MANIFEST_DIR/local-pv.yml"
                apply_manifest "$MANIFEST_DIR/namespace.yml"
                apply_manifest "$MANIFEST_DIR/local-pvc.yml"
                apply_manifest "$MANIFEST_DIR/configmap.yml"
                apply_manifest "$MANIFEST_DIR/secret.yml"
                apply_manifest "$MANIFEST_DIR/service.yml"
                apply_manifest "$MANIFEST_DIR/deployment.yml"
                # apply_manifest "$MANIFEST_DIR/ingress.yml"  # Commented out as in original
                
                echo "=== Cleaning up Docker resources ==="
                echo "Removing unused Docker images..."
                docker rmi -f $(docker images -q) 2>/dev/null || echo "No images to remove or command failed"
                
                echo "Pruning Docker system..."
                docker system prune -a --volumes --force || echo "Docker system prune failed"
                
                echo "=== Deployment completed ==="

          - task: Bash@3
            displayName: 'Phoenix done!'
            inputs:
              targetType: 'inline'
              script: |
                PHOENIX_FILE="$(Build.SourcesDirectory)/deployment/phoenix/readme"
                echo "=== Phoenix Phase ==="
                if [ -f "$PHOENIX_FILE" ]; then
                    echo "Phoenix readme-dev contents:"
                    cat "$PHOENIX_FILE"
                else
                    echo "Phoenix readme-dev file not found at $PHOENIX_FILE"
                    echo "Available files in phoenix directory:"
                    ls -la "$(Build.SourcesDirectory)/deployment/phoenix/" 2>/dev/null || echo "Phoenix directory not found"

# =====================================
# NOTIFICATION STAGE
# =====================================
- stage: Notification
  displayName: 'Send Notifications'
  dependsOn: 
  - DeployProd
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  variables:
  - group: PROD
  
  jobs:
  - job: SendNotification
    displayName: 'Send Deployment Notifications'
    pool:
      name: Agents_Win_Linux
      demands: Agent.OS -equals Linux
    
    steps:
    - task: PowerShell@2
      displayName: 'Send Email Notification'
      inputs:
        targetType: 'inline'
        script: |
          # Determine final status
          $jobStatus = "$(Agent.JobStatus)"
          Write-Host "Deployment completed with status: $jobStatus"
          $stageStatus = if ($jobStatus -eq "Succeeded") { "‚úÖ Deployment successful" } else { "‚ùå Deployment failed" }
          $statusColor = if ($jobStatus -eq "Succeeded") { "#107c10" } else { "#d13438" }
          
          # Email configuration
          $smtpServer = "$(SmtpServer)"
          $smtpPort = "$(SmtpPort)"
          $fromEmail = "$(FromEmail)"
          $toEmails = "$(ToEmails)"  -split ";"
          $emailUser = "$(EmailUser)"
          $emailPassword = "$(EmailPassword)"
          
          # Pipeline information
          $buildNumber = "$(Build.BuildNumber)"
          $environment = "$(DeploymentEnvironment)"
          $projectName = "$(imageRepository)"
          $buildUrl = "$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
          
          # Create completion email
          $subject = "$stageStatus - $projectName - $environment - Build #$buildNumber"
          $body = @"
          <html>
          <head>
              <style>
                  body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
                  .container { max-width: 600px; margin: 0 auto; }
                  .header { background-color: $statusColor; color: white; padding: 20px; text-align: center; }
                  .content { padding: 20px; background-color: #f9f9f9; }
                  .footer { background-color: #333; color: white; padding: 10px; text-align: center; }
                  table { width: 100%; border-collapse: collapse; margin: 15px 0; }
                  th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
                  th { background-color: #f2f2f2; font-weight: bold; }
                  .button { background-color: #0078d4; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px; display: inline-block; margin: 10px 0; }
              </style>
          </head>
          <body>
              <div class="container">
                  <div class="header">
                      <h1>Pipeline Execution Complete</h1>
                      <h2 style="margin: 0;">Status: $stageStatus</h2>
                  </div>
                  <div class="content">
                      <h3>Pipeline Summary</h3>
                      <table>
                          <tr><th>Project</th><td>$projectName</td></tr>
                          <tr><th>Environment</th><td>$environment</td></tr>
                          <tr><th>Build Number</th><td>$buildNumber</td></tr>
                          <tr><th>Final Status</th><td style="color: $statusColor; font-weight: bold;">$stageStatus</td></tr>
                          <tr><th>Completed At</th><td>$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')</td></tr>
                          <tr><th>Requested By</th><td>$(Build.RequestedFor)</td></tr>
                          <tr><th>Source Branch</th><td>$(Build.SourceBranch)</td></tr>
                      </table>
                      
                      <p>The pipeline execution has completed. Click the button below to view detailed results:</p>
                      <a href="$buildUrl" class="button">View Pipeline Results</a>
                  </div>
                  <div class="footer">
                      <p>Azure f - Automated Pipeline Notification</p>
                  </div>
              </div>
          </body>
          </html>
          "@
          
          try 
          {
              # Create mail message
              $mailMessage = New-Object System.Net.Mail.MailMessage
              $mailMessage.From = $fromEmail
              # Add each recipient individually
              foreach ($email in $toEmails) 
              {
                  if (![string]::IsNullOrWhiteSpace($email)) 
                  {
                    $mailMessage.To.Add($email.Trim())
                  }
              }
              $mailMessage.Subject = $subject
              $mailMessage.Body = $body
              $mailMessage.IsBodyHtml = $true  

              # Configure SMTP client
              $smtpClient = New-Object System.Net.Mail.SmtpClient($smtpServer, $smtpPort)

              # If authentication is required
              $smtpClient.Credentials = New-Object System.Net.NetworkCredential($emailUser, $emailPassword)

              # Enable SSL/TLS if required (recommended)
              $smtpClient.EnableSsl = $true

              # Send email
              $smtpClient.Send($mailMessage)

              Write-Host "Pipeline completion notification sent successfully"
              Write-Host "$stageStatus"
          }
          catch 
          {
              Write-Host "Failed to send completion notification: $($_.Exception.Message)" -ForegroundColor Red
              exit 1
          }