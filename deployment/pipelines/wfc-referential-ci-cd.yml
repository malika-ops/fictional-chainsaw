trigger:
- main

resources:
  - repo: self

parameters:
  - name: Build_Release
    type: boolean
    default: true
    
name: 9.9$(Rev:.r)

variables:
  - name: currentBranchName 
    value: '$(Build.SourceBranchName)'
  - name: buildConfiguration 
    value: 'Release'
  - name: imageRepository 
    value: 'phoenix/wfc-referential-api'
  - name: tag 
    value: '$(Build.BuildId)'
  - name: dockerRegistryServiceConnection
    value: 'Harbor-Registry'

stages:
- stage: Build_CI
  condition: eq(${{parameters.Build_Release}}, 'true')
  displayName: Build CI
  jobs:
  - job: Build_CI
    displayName: Build and push image docker
    pool:
      name: Agents_Win_Linux
      demands: Agent.OS -equals Linux
    workspace:
      clean: all
    steps:
    - task: UseDotNet@2
      displayName: "Use .NET Core sdk 8.0.x"
      inputs:
        version: 8.0.x

    - task: NuGetToolInstaller@1
      displayName: 'Use NuGet'
      inputs:
        versionSpec: '6.x'

    - task: NuGetAuthenticate@1
      displayName: 'NuGet Authenticate'
      inputs:
        forceReinstallCredentialProvider: true
      env:
        DOTNET_SYSTEM_NET_HTTP_USESOCKETSHTTPHANDLER: '0'
        SSL_CERT_FILE: '/etc/ssl/certs/wafacash-MASSA-CA.crt'
        SSL_CERT_DIR: '/etc/ssl/certs'
        NODE_EXTRA_CA_CERTS: '/etc/ssl/certs/ca-certificates.crt'
        REQUESTS_CA_BUNDLE: '/etc/ssl/certs/ca-certificates.crt'
        CURL_CA_BUNDLE: '/etc/ssl/certs/ca-certificates.crt'
        NODE_TLS_REJECT_UNAUTHORIZED: '0'

    - task: DotNetCoreCLI@2
      displayName: 'Restore solution'
      inputs:
        command: 'restore'
        projects: 'src/**/**/*.csproj'
        feedsToUse: 'config'
        nugetConfigPath: 'nuget.config'
        workingDirectory: '$(Build.SourcesDirectory)'

    - task: DotNetCoreCLI@2
      displayName: 'Build solution'
      inputs:
        command: 'build'
        projects: 'src/**/**/*.csproj'
        arguments: '--configuration $(buildConfiguration) --no-restore'

    - task: Bash@3
      displayName: 'Install EF Core CLI Tools if needed'
      inputs:
        targetType: 'inline'
        script: |
          echo "=== Checking if EF Core CLI is installed ==="
          
          if dotnet ef --version; then
              echo "‚úÖ EF Core CLI is already installed"
          else
              echo "‚ùå EF Core CLI not found, installing..."
              dotnet tool install --global dotnet-ef
              echo "‚úÖ EF Core CLI installed successfully"
          fi
          
          echo "Current EF Core CLI version:"
          dotnet ef --version
      condition: succeeded()

    - task: Bash@3
      displayName: 'Generate EF Migration Scripts'
      inputs:
        targetType: 'inline'
        script: |
          echo "=== Generating EF Core Migration Scripts ==="
          
          # Variables
          STARTUP_PROJECT="src/01.InterfaceAdapter/wfc.referential.API/wfc.referential.API.csproj"
          INFRASTRUCTURE_PROJECT="src/04.Infrastructure/wfc.referential.Infrastructure/wfc.referential.Infrastructure.csproj"
          OUTPUT_FILE="$(Build.ArtifactStagingDirectory)/migration-script.sql"
          
          # Cr√©er le r√©pertoire de sortie
          mkdir -p "$(Build.ArtifactStagingDirectory)"
          
          # V√©rifier que les projets existent
          if [ ! -f "$STARTUP_PROJECT" ]; then
              echo "‚ùå Startup project not found: $STARTUP_PROJECT"
              exit 1
          fi
          
          if [ ! -f "$INFRASTRUCTURE_PROJECT" ]; then
              echo "‚ùå Infrastructure project not found: $INFRASTRUCTURE_PROJECT"
              exit 1
          fi
          
          echo "‚úÖ Projects found - generating migration script..."
          
          # G√©n√©rer les scripts de migration
          dotnet ef migrations script \
            --output "$OUTPUT_FILE" \
            --idempotent \
            --configuration $(buildConfiguration) \
            --startup-project "$STARTUP_PROJECT" \
            --project "$INFRASTRUCTURE_PROJECT" \
            --verbose
          
          if [ $? -eq 0 ] && [ -f "$OUTPUT_FILE" ]; then
              echo "‚úÖ Migration script generated successfully"
              echo "File size: $(stat -c%s "$OUTPUT_FILE") bytes"
              
              # Validation du contenu
              if [ -s "$OUTPUT_FILE" ]; then
                  echo "‚úÖ Migration script contains data"
                  echo "First few lines:"
                  head -5 "$OUTPUT_FILE"
              else
                  echo "‚ö†Ô∏è Migration script is empty - no pending migrations"
              fi
          else
              echo "‚ùå Migration script generation failed"
              exit 1
          fi
        workingDirectory: '$(Build.SourcesDirectory)'
      condition: succeeded()

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Migration Scripts'
      inputs:
        pathtoPublish: '$(Build.ArtifactStagingDirectory)/migration-script.sql'
        artifactName: 'migration-scripts'
        publishLocation: 'Container'
      condition: succeeded()
        
    - task: DotNetCoreCLI@2
      displayName: 'Add coverlet.collector package'
      inputs:
        command: 'custom'
        custom: 'add'
        arguments: 'package coverlet.collector'
        projects: '**/*[Tt]ests.csproj'

    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests'
      timeoutInMinutes: 10
      inputs:
        command: 'test'
        projects: '**/*[Tt]ests.csproj'
        arguments: '--configuration $(buildConfiguration) --logger "trx" --collect:"XPlat Code Coverage" --results-directory $(Agent.TempDirectory)/TestResults'
        publishTestResults: false  # Changed to false - we'll publish manually
        failTaskOnFailedTests: true
        workingDirectory: '$(Build.SourcesDirectory)'

    ## Publish test results
    - task: PublishTestResults@2
      displayName: 'Publish Test Results'
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '**/*.trx'  # Changed to search for all .trx files
        searchFolder: '$(Agent.TempDirectory)/TestResults'  # Specific folder
        mergeTestResults: true
        failTaskOnFailedTests: true
        testRunTitle: 'Unit Tests - $(Build.BuildNumber)'
      condition: succeededOrFailed()

    - task: DotNetCoreCLI@2
      displayName: "publish solution"
      inputs:
        command: publish
        publishWebProjects: false
        projects: 'src/**/**/*.csproj'
        zipAfterPublish: false
        arguments: "-o $(Build.SourcesDirectory)/src/Output"

    - script: |
        echo "Contents of the publish directory:"
        ls -R $(Build.SourcesDirectory)/src/Output
      displayName: 'Display publish directory contents'

    - task: Docker@2
      displayName: Docker Build
      inputs:
        command: Build
        dockerfile: $(Build.SourcesDirectory)/deployment/dockerfile/wfc-referential-api.dockerfile
        buildContext: $(Build.SourcesDirectory)
        containerRegistry: $(dockerRegistryServiceConnection)
        repository: $(imageRepository)
        tags: |
          latest
          $(tag)
        arguments: "--build-arg NUGET_PAT=$(System.AccessToken)"

    - task: Docker@2
      displayName: Docker Push to Harbor
      inputs:
        command: Push
        dockerfile: $(Build.SourcesDirectory)/deployment/dockerfile/wfc-referential-api.dockerfile
        buildContext: $(Build.SourcesDirectory)
        containerRegistry: $(dockerRegistryServiceConnection)
        repository: $(imageRepository)
        tags: |
          latest
          $(tag)

- stage: DeployDev
  displayName: Deploy to Development
  dependsOn: Build_CI
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: DeployDev
    displayName: Deploy to Dev Environment
    pool:
      name: Agents_Win_Linux
      demands: Agent.OS -equals Linux
    workspace:
      clean: all
    environment: 'DEV'
    variables:
    - group: DEV
    strategy:
      runOnce:
        deploy:
          steps:
          # Work directly with source files - no artifacts needed
          - checkout: self
            clean: true
            displayName: 'Checkout source code'

          - script: |
              echo "=== Checking deployment files ==="
              ls -la $(Build.SourcesDirectory)/deployment/k8-manifests/ || echo "k8-manifests not found"
              ls -la $(Build.SourcesDirectory)/deployment/phoenix/ || echo "phoenix not found"
            displayName: 'Verify deployment files exist'

          - task: qetza.replacetokens.replacetokens-task.replacetokens@6
            displayName: 'Replace tokens in manifests'
            inputs:
              rootDirectory: '$(Build.SourcesDirectory)/deployment/k8-manifests'
              targetFiles: '**/*.yml'
              encoding: 'auto'
              tokenPattern: 'default'
              writeBOM: true
              actionOnMissing: 'warn'
              keepToken: false
              actionOnNoFiles: 'continue'
              enableTransforms: false
              enableRecursion: false
              useLegacyPattern: false
              enableTelemetry: true

          - task: DownloadBuildArtifacts@1
              displayName: 'Download Migration Scripts'
              inputs:
                buildType: 'current'
                downloadType: 'single'
                artifactName: 'migration-scripts'
                downloadPath: '$(System.ArtifactsDirectory)'

          - task: Bash@3
            displayName: 'Install PostgreSQL Client Tools (if needed)'
            inputs:
              targetType: 'inline'
              script: |
                echo "=== Checking PostgreSQL Client Tools ==="
                
                # V√©rifier si psql est d√©j√† install√©
                if command -v psql &> /dev/null; then
                    echo "‚úÖ psql is already installed"
                    psql --version
                    exit 0
                fi
                
                echo "üì¶ Installing PostgreSQL Client Tools..."
                
                # Installation optimis√©e
                sudo apt-get update -qq
                sudo apt-get install -y postgresql-client
                
                # V√©rifier l'installation
                psql --version
                echo "‚úÖ PostgreSQL Client Tools installed successfully"
            condition: succeeded()

        - task: Bash@3
          displayName: 'Execute EF Core Migrations'
          inputs:
            targetType: 'inline'
            script: |
              echo "=== Executing EF Core Migrations ==="
              
              # Variables
              MIGRATION_SCRIPT="$(System.ArtifactsDirectory)/migration-scripts/migration-script.sql"
              
              # V√©rifier que le script existe
              if [ ! -f "$MIGRATION_SCRIPT" ]; then
                  echo "‚ùå Migration script not found at: $MIGRATION_SCRIPT"
                  echo "Available files:"
                  ls -la "$(System.ArtifactsDirectory)/migration-scripts/" || echo "Directory not found"
                  exit 1
              fi
              
              # V√©rifier que psql existe
              if ! command -v psql &> /dev/null; then
                  echo "‚ùå psql not found in PATH"
                  exit 1
              fi
              
              echo "‚úÖ Migration script found: $MIGRATION_SCRIPT"
              echo "‚úÖ psql found: $(which psql)"
              echo "Script size: $(stat -c%s "$MIGRATION_SCRIPT") bytes"
              
              # V√©rifier que le script n'est pas vide
              if [ ! -s "$MIGRATION_SCRIPT" ]; then
                  echo "‚ö†Ô∏è Migration script is empty - no migrations to execute"
                  exit 0
              fi
              
              # Param√®tres de connexion
              echo "=== Connection Parameters ==="
              echo "Host: $(DB_HOST)"
              echo "Port: $(DB_PORT)"
              echo "Database: $(DB_NAME)"
              echo "User: $(DB_USER)"
              echo "Password: [MASKED]"
              
              # Construire la cha√Æne de connexion PostgreSQL
              export PGPASSWORD="$(DB_PASSWORD)"
              
              # Test de connexion
              echo "=== Testing database connection ==="
              psql -h "$(DB_HOST)" -p "$(DB_PORT)" -U "$(DB_USER)" -d "$(DB_NAME)" -c "SELECT version();" -t
              
              if [ $? -ne 0 ]; then
                  echo "‚ùå Database connection test failed"
                  exit 1
              fi
              
              echo "‚úÖ Database connection successful"
              
              # Ex√©cuter les migrations avec gestion d'erreur
              echo "=== Executing migrations ==="
              psql -h "$(DB_HOST)" \
                  -p "$(DB_PORT)" \
                  -U "$(DB_USER)" \
                  -d "$(DB_NAME)" \
                  -f "$MIGRATION_SCRIPT" \
                  -v ON_ERROR_STOP=1 \
                  --echo-errors
              
              PSQL_EXIT_CODE=$?
              
              # Nettoyer la variable de mot de passe
              unset PGPASSWORD
              
              if [ $PSQL_EXIT_CODE -eq 0 ]; then
                  echo "‚úÖ Migrations executed successfully"
              else
                  echo "‚ùå Migration execution failed with exit code: $PSQL_EXIT_CODE"
                  exit 1
              fi
          condition: succeeded()

          - task: Bash@3
            displayName: 'Deploy to Kubernetes cluster'
            inputs:
              targetType: 'inline'
              script: |
                MANIFEST_DIR="$(Build.SourcesDirectory)/deployment/k8-manifests/"
                
                echo "=== Verifying manifest files exist ==="
                if [ ! -d "$MANIFEST_DIR" ]; then
                    echo "ERROR: Manifest directory not found at $MANIFEST_DIR"
                    exit 1
                fi
                
                echo "Files in manifest directory:"
                ls -la "$MANIFEST_DIR"
                
                echo "=== Applying Kubernetes manifests ==="
                
                # Apply manifests one by one with error checking
                apply_manifest() {
                    local file="$1"
                    if [ -f "$file" ]; then
                        echo "Applying $file..."
                        kubectl apply -f "$file"
                        if [ $? -eq 0 ]; then
                            echo "‚úì Successfully applied $file"
                        else
                            echo "‚úó Failed to apply $file"
                            return 1
                        fi
                    else
                        echo "‚ö† File $file not found, skipping..."
                    fi
                }
                
                # Apply in correct order
                apply_manifest "$MANIFEST_DIR/local-storageclass.yml"
                apply_manifest "$MANIFEST_DIR/local-pv.yml"
                apply_manifest "$MANIFEST_DIR/namespace.yml"
                apply_manifest "$MANIFEST_DIR/local-pvc.yml"
                apply_manifest "$MANIFEST_DIR/configmap.yml"
                apply_manifest "$MANIFEST_DIR/secret.yml"
                apply_manifest "$MANIFEST_DIR/service.yml"
                apply_manifest "$MANIFEST_DIR/deployment.yml"
                # apply_manifest "$MANIFEST_DIR/ingress.yml"  # Commented out as in original
                
                echo "=== Cleaning up Docker resources ==="
                echo "Removing unused Docker images..."
                docker rmi -f $(docker images -q) 2>/dev/null || echo "No images to remove or command failed"
                
                echo "Pruning Docker system..."
                docker system prune -a --volumes --force || echo "Docker system prune failed"
                
                echo "=== Deployment completed ==="

          - task: Bash@3
            displayName: 'Phoenix done!'
            inputs:
              targetType: 'inline'
              script: |
                PHOENIX_FILE="$(Build.SourcesDirectory)/deployment/phoenix/readme-dev"
                echo "=== Phoenix Phase ==="
                if [ -f "$PHOENIX_FILE" ]; then
                    echo "Phoenix readme-dev contents:"
                    cat "$PHOENIX_FILE"
                else
                    echo "Phoenix readme-dev file not found at $PHOENIX_FILE"
                    echo "Available files in phoenix directory:"
                    ls -la "$(Build.SourcesDirectory)/deployment/phoenix/" 2>/dev/null || echo "Phoenix directory not found"
                fi
                
- stage: DeployPprod
  displayName: Deploy to PPROD
  dependsOn: 
  - Build_CI
  - DeployDev
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  # Pre-deployment approval
  - job: PreDeploymentApproval
    displayName: 'Pre-Deployment Approval Gate'
    pool: server
    timeoutInMinutes: 4320 # 3 days timeout
    variables:
    - group: PPROD
    
    steps:
    - task: ManualValidation@0
      displayName: 'Manual Approval Required'
      inputs:
        notifyUsers: "$(notifyUsers)"
        instructions: |
          Please review the following before approving deployment to PRE-PROD:
          
          ‚úÖ Build Quality Gates Passed
          ‚úÖ Unit Tests Passed  
          ‚úÖ Security Scan Completed
          ‚úÖ Performance Tests Validated
          ‚úÖ Business Stakeholder Sign-off
          
          Deployment Details:
          - Build Number: $(Build.BuildNumber)
          - Source Branch: $(Build.SourceBranch)
          - Triggered By: $(Build.RequestedFor)
          
          Check the boxes above and click "Resume" to proceed with dev deployment.
        onTimeout: 'reject'
        
  - deployment: DeployPprod
    displayName: Deploy to PRE-PRODUCTION Environment
    dependsOn: PreDeploymentApproval
    pool:
      name: Agents_Win_Linux
      demands: Agent.OS -equals Linux
    workspace:
      clean: all
    environment: 'PPROD'
    variables:
    - group: PPROD
    strategy:
      runOnce:
        deploy:
          steps:
          # Work directly with source files - no artifacts needed
          - checkout: self
            clean: true
            displayName: 'Checkout source code'

          - script: |
              echo "=== Checking deployment files ==="
              ls -la $(Build.SourcesDirectory)/deployment/k8-manifests/ || echo "k8-manifests not found"
              ls -la $(Build.SourcesDirectory)/deployment/phoenix/ || echo "phoenix not found"
            displayName: 'Verify deployment files exist'

          - task: qetza.replacetokens.replacetokens-task.replacetokens@6
            displayName: 'Replace tokens in manifests'
            inputs:
              rootDirectory: '$(Build.SourcesDirectory)/deployment/k8-manifests'
              targetFiles: '**/*.yml'
              encoding: 'auto'
              tokenPattern: 'default'
              writeBOM: true
              actionOnMissing: 'warn'
              keepToken: false
              actionOnNoFiles: 'continue'
              enableTransforms: false
              enableRecursion: false
              useLegacyPattern: false
              enableTelemetry: true

          - task: Bash@3
            displayName: 'Deploy to Kubernetes cluster'
            inputs:
              targetType: 'inline'
              script: |
                MANIFEST_DIR="$(Build.SourcesDirectory)/deployment/k8-manifests/"
                
                echo "=== Verifying manifest files exist ==="
                if [ ! -d "$MANIFEST_DIR" ]; then
                    echo "ERROR: Manifest directory not found at $MANIFEST_DIR"
                    exit 1
                fi
                
                echo "Files in manifest directory:"
                ls -la "$MANIFEST_DIR"
                
                echo "=== Applying Kubernetes manifests ==="
                
                # Apply manifests one by one with error checking
                apply_manifest() {
                    local file="$1"
                    if [ -f "$file" ]; then
                        echo "Applying $file..."
                        kubectl apply -f "$file"
                        if [ $? -eq 0 ]; then
                            echo "‚úì Successfully applied $file"
                        else
                            echo "‚úó Failed to apply $file"
                            return 1
                        fi
                    else
                        echo "‚ö† File $file not found, skipping..."
                    fi
                }
                
                # Apply in correct order
                apply_manifest "$MANIFEST_DIR/local-storageclass.yml"
                apply_manifest "$MANIFEST_DIR/local-pv.yml"
                apply_manifest "$MANIFEST_DIR/namespace.yml"
                apply_manifest "$MANIFEST_DIR/local-pvc.yml"
                apply_manifest "$MANIFEST_DIR/configmap.yml"
                apply_manifest "$MANIFEST_DIR/secret.yml"
                apply_manifest "$MANIFEST_DIR/service.yml"
                apply_manifest "$MANIFEST_DIR/deployment.yml"
                # apply_manifest "$MANIFEST_DIR/ingress.yml"  # Commented out as in original
                
                echo "=== Cleaning up Docker resources ==="
                echo "Removing unused Docker images..."
                docker rmi -f $(docker images -q) 2>/dev/null || echo "No images to remove or command failed"
                
                echo "Pruning Docker system..."
                docker system prune -a --volumes --force || echo "Docker system prune failed"
                
                echo "=== Deployment completed ==="

          - task: Bash@3
            displayName: 'Phoenix done!'
            inputs:
              targetType: 'inline'
              script: |
                PHOENIX_FILE="$(Build.SourcesDirectory)/deployment/phoenix/readme-pprd"
                echo "=== Phoenix Phase ==="
                if [ -f "$PHOENIX_FILE" ]; then
                    echo "Phoenix readme-dev contents:"
                    cat "$PHOENIX_FILE"
                else
                    echo "Phoenix readme-dev file not found at $PHOENIX_FILE"
                    echo "Available files in phoenix directory:"
                    ls -la "$(Build.SourcesDirectory)/deployment/phoenix/" 2>/dev/null || echo "Phoenix directory not found"

- stage: DeployProd
  displayName: Deploy to Production
  dependsOn: 
  - Build_CI
  - DeployPprod
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  # Pre-deployment approval
  - job: PreDeploymentApproval
    displayName: 'Pre-Deployment Approval Gate'
    pool: server
    timeoutInMinutes: 4320 # 3 days timeout
    variables:
    - group: PROD
    
    steps:
    - task: ManualValidation@0
      displayName: 'Manual Approval Required'
      inputs:
        notifyUsers: "$(notifyUsers)"
        instructions: |
          Please review the following before approving deployment to PROD:
          
          ‚úÖ Build Quality Gates Passed
          ‚úÖ Unit Tests Passed  
          ‚úÖ Security Scan Completed
          ‚úÖ Performance Tests Validated
          ‚úÖ Business Stakeholder Sign-off
          
          Deployment Details:
          - Build Number: $(Build.BuildNumber)
          - Source Branch: $(Build.SourceBranch)
          - Triggered By: $(Build.RequestedFor)
          
          Check the boxes above and click "Resume" to proceed with dev deployment.
        onTimeout: 'reject'
        
  - deployment: DeployProd
    displayName: Deploy to Prod Environment
    dependsOn: PreDeploymentApproval
    pool:
      name: Agents_Win_Linux
      demands: Agent.OS -equals Linux
    workspace:
      clean: all
    environment: 'PROD'
    variables:
    - group: PROD
    strategy:
      runOnce:
        deploy:
          steps:
          # Work directly with source files - no artifacts needed
          - checkout: self
            clean: true
            displayName: 'Checkout source code'

          - script: |
              echo "=== Checking deployment files ==="
              ls -la $(Build.SourcesDirectory)/deployment/k8-manifests/ || echo "k8-manifests not found"
              ls -la $(Build.SourcesDirectory)/deployment/phoenix/ || echo "phoenix not found"
            displayName: 'Verify deployment files exist'

          - task: qetza.replacetokens.replacetokens-task.replacetokens@6
            displayName: 'Replace tokens in manifests'
            inputs:
              rootDirectory: '$(Build.SourcesDirectory)/deployment/k8-manifests'
              targetFiles: '**/*.yml'
              encoding: 'auto'
              tokenPattern: 'default'
              writeBOM: true
              actionOnMissing: 'warn'
              keepToken: false
              actionOnNoFiles: 'continue'
              enableTransforms: false
              enableRecursion: false
              useLegacyPattern: false
              enableTelemetry: true

          - task: Bash@3
            displayName: 'Deploy to Kubernetes cluster'
            inputs:
              targetType: 'inline'
              script: |
                MANIFEST_DIR="$(Build.SourcesDirectory)/deployment/k8-manifests/"
                
                echo "=== Verifying manifest files exist ==="
                if [ ! -d "$MANIFEST_DIR" ]; then
                    echo "ERROR: Manifest directory not found at $MANIFEST_DIR"
                    exit 1
                fi
                
                echo "Files in manifest directory:"
                ls -la "$MANIFEST_DIR"
                
                echo "=== Applying Kubernetes manifests ==="
                
                # Apply manifests one by one with error checking
                apply_manifest() {
                    local file="$1"
                    if [ -f "$file" ]; then
                        echo "Applying $file..."
                        kubectl apply -f "$file"
                        if [ $? -eq 0 ]; then
                            echo "‚úì Successfully applied $file"
                        else
                            echo "‚úó Failed to apply $file"
                            return 1
                        fi
                    else
                        echo "‚ö† File $file not found, skipping..."
                    fi
                }
                
                # Apply in correct order
                apply_manifest "$MANIFEST_DIR/local-storageclass.yml"
                apply_manifest "$MANIFEST_DIR/local-pv.yml"
                apply_manifest "$MANIFEST_DIR/namespace.yml"
                apply_manifest "$MANIFEST_DIR/local-pvc.yml"
                apply_manifest "$MANIFEST_DIR/configmap.yml"
                apply_manifest "$MANIFEST_DIR/secret.yml"
                apply_manifest "$MANIFEST_DIR/service.yml"
                apply_manifest "$MANIFEST_DIR/deployment.yml"
                # apply_manifest "$MANIFEST_DIR/ingress.yml"  # Commented out as in original
                
                echo "=== Cleaning up Docker resources ==="
                echo "Removing unused Docker images..."
                docker rmi -f $(docker images -q) 2>/dev/null || echo "No images to remove or command failed"
                
                echo "Pruning Docker system..."
                docker system prune -a --volumes --force || echo "Docker system prune failed"
                
                echo "=== Deployment completed ==="

          - task: Bash@3
            displayName: 'Phoenix done!'
            inputs:
              targetType: 'inline'
              script: |
                PHOENIX_FILE="$(Build.SourcesDirectory)/deployment/phoenix/readme"
                echo "=== Phoenix Phase ==="
                if [ -f "$PHOENIX_FILE" ]; then
                    echo "Phoenix readme-dev contents:"
                    cat "$PHOENIX_FILE"
                else
                    echo "Phoenix readme-dev file not found at $PHOENIX_FILE"
                    echo "Available files in phoenix directory:"
                    ls -la "$(Build.SourcesDirectory)/deployment/phoenix/" 2>/dev/null || echo "Phoenix directory not found"

# =====================================
# NOTIFICATION STAGE
# =====================================
- stage: Notification
  displayName: 'Send Notifications'
  dependsOn: 
  - DeployProd
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  variables:
  - group: PROD
  
  jobs:
  - job: SendNotification
    displayName: 'Send Deployment Notifications'
    pool:
      name: Agents_Win_Linux
      demands: Agent.OS -equals Linux
    
    steps:
    - task: PowerShell@2
      displayName: 'Send Email Notification'
      inputs:
        targetType: 'inline'
        script: |
          # Determine final status
          $jobStatus = "$(Agent.JobStatus)"
          Write-Host "Deployment completed with status: $jobStatus"
          $stageStatus = if ($jobStatus -eq "Succeeded") { "‚úÖ Deployment successful" } else { "‚ùå Deployment failed" }
          $statusColor = if ($jobStatus -eq "Succeeded") { "#107c10" } else { "#d13438" }
          
          # Email configuration
          $smtpServer = "$(SmtpServer)"
          $smtpPort = "$(SmtpPort)"
          $fromEmail = "$(FromEmail)"
          $toEmails = "$(ToEmails)"  -split ";"
          $emailUser = "$(EmailUser)"
          $emailPassword = "$(EmailPassword)"
          
          # Pipeline information
          $buildNumber = "$(Build.BuildNumber)"
          $environment = "$(DeploymentEnvironment)"
          $projectName = "$(imageRepository)"
          $buildUrl = "$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
          
          # Create completion email
          $subject = "$stageStatus - $projectName - $environment - Build #$buildNumber"
          $body = @"
          <html>
          <head>
              <style>
                  body { font-family: Arial, sans-serif; margin: 0; padding: 0; }
                  .container { max-width: 600px; margin: 0 auto; }
                  .header { background-color: $statusColor; color: white; padding: 20px; text-align: center; }
                  .content { padding: 20px; background-color: #f9f9f9; }
                  .footer { background-color: #333; color: white; padding: 10px; text-align: center; }
                  table { width: 100%; border-collapse: collapse; margin: 15px 0; }
                  th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
                  th { background-color: #f2f2f2; font-weight: bold; }
                  .button { background-color: #0078d4; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px; display: inline-block; margin: 10px 0; }
              </style>
          </head>
          <body>
              <div class="container">
                  <div class="header">
                      <h1>Pipeline Execution Complete</h1>
                      <h2 style="margin: 0;">Status: $stageStatus</h2>
                  </div>
                  <div class="content">
                      <h3>Pipeline Summary</h3>
                      <table>
                          <tr><th>Project</th><td>$projectName</td></tr>
                          <tr><th>Environment</th><td>$environment</td></tr>
                          <tr><th>Build Number</th><td>$buildNumber</td></tr>
                          <tr><th>Final Status</th><td style="color: $statusColor; font-weight: bold;">$stageStatus</td></tr>
                          <tr><th>Completed At</th><td>$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')</td></tr>
                          <tr><th>Requested By</th><td>$(Build.RequestedFor)</td></tr>
                          <tr><th>Source Branch</th><td>$(Build.SourceBranch)</td></tr>
                      </table>
                      
                      <p>The pipeline execution has completed. Click the button below to view detailed results:</p>
                      <a href="$buildUrl" class="button">View Pipeline Results</a>
                  </div>
                  <div class="footer">
                      <p>Azure f - Automated Pipeline Notification</p>
                  </div>
              </div>
          </body>
          </html>
          "@
          
          try 
          {
              # Create mail message
              $mailMessage = New-Object System.Net.Mail.MailMessage
              $mailMessage.From = $fromEmail
              # Add each recipient individually
              foreach ($email in $toEmails) 
              {
                  if (![string]::IsNullOrWhiteSpace($email)) 
                  {
                    $mailMessage.To.Add($email.Trim())
                  }
              }
              $mailMessage.Subject = $subject
              $mailMessage.Body = $body
              $mailMessage.IsBodyHtml = $true  

              # Configure SMTP client
              $smtpClient = New-Object System.Net.Mail.SmtpClient($smtpServer, $smtpPort)

              # If authentication is required
              $smtpClient.Credentials = New-Object System.Net.NetworkCredential($emailUser, $emailPassword)

              # Enable SSL/TLS if required (recommended)
              $smtpClient.EnableSsl = $true

              # Send email
              $smtpClient.Send($mailMessage)

              Write-Host "Pipeline completion notification sent successfully"
              Write-Host "$stageStatus"
          }
          catch 
          {
              Write-Host "Failed to send completion notification: $($_.Exception.Message)" -ForegroundColor Red
              exit 1
          }